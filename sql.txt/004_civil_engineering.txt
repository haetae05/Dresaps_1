-- [DRESAPS V4.0] Civil Engineering (Domain 13)
-- Infrastructure Automation, Optimization, and Safety
-- Generated by Antigravity Agent

-- 1. Extensions & Performance [Section 2.3]
CREATE EXTENSION IF NOT EXISTS "pg_cron";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- [Section 2.3] Pagination Optimization
-- Index for Feed: Sort by Created At DESC, Filter by User
CREATE INDEX IF NOT EXISTS idx_posts_pagination 
ON public.posts (created_at DESC, user_id);

-- [Section 2.3] Fuzzy Search Optimization
-- GIN Trigram Index for fast username search (LIKE %query%)
CREATE INDEX IF NOT EXISTS idx_profiles_username_trgm 
ON public.profiles 
USING GIN (username gist_trgm_ops);

-- [Section 2.3] Worker Queue Optimization
-- Partial Index: Only index 'pending' jobs for O(1) worker lookup
CREATE INDEX IF NOT EXISTS idx_jobs_pending 
ON public.generation_jobs (created_at) 
WHERE status = 'pending';


-- 2. Safety Triggers & Logic [Section 4]

-- [Section 4] Auto Refund Trigger
-- Refunds 1 Film when a generation job is marked as 'dead' (failed/timeout).
CREATE OR REPLACE FUNCTION public.handle_auto_refund() 
RETURNS TRIGGER 
LANGUAGE plpgsql 
SECURITY DEFINER 
AS $$
BEGIN
    IF NEW.status = 'dead' AND OLD.status != 'dead' THEN
        -- Call the secure deposit function from 001_logic_functions.sql
        PERFORM public.deposit_film(
            NEW.user_id, 
            1, 
            'System Refund: Job Error ' || NEW.id
        );
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS on_job_dead ON public.generation_jobs;
CREATE TRIGGER on_job_dead
AFTER UPDATE ON public.generation_jobs
FOR EACH ROW EXECUTE FUNCTION public.handle_auto_refund();

-- [Section 4.2] Atomic Counter Logic (Upsert)
CREATE OR REPLACE FUNCTION public.increment_api_usage(
    p_user_id UUID,
    p_counter_key TEXT
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.api_usage_counters (user_id, counter_key, count, last_updated)
    VALUES (p_user_id, p_counter_key, 1, NOW())
    ON CONFLICT (user_id, counter_key)
    DO UPDATE SET 
        count = public.api_usage_counters.count + 1,
        last_updated = NOW();
END;
$$;


-- 3. Archiving [Section 5.2]
-- [Section 5.2] Magazine Archives (Decoupled Snapshot)
-- Stores immutable snapshots of monthly magazines/collections.
CREATE TABLE IF NOT EXISTS public.magazine_archives (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    issue_date DATE NOT NULL,
    title TEXT NOT NULL,
    snapshot_data JSONB NOT NULL, -- Full JSON dump, no Foreign Keys to posts
    created_at TIMESTAMPTZ DEFAULT NOW()
);
-- RLS for Archives
ALTER TABLE public.magazine_archives ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public Read Archives" ON public.magazine_archives FOR SELECT USING (true);


-- 4. Automation Schedules (pg_cron) [Section 5.1]

-- [Section 5.1] Audit Logs for Cron Jobs
CREATE TABLE IF NOT EXISTS public.cron_audit_logs (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    job_name TEXT NOT NULL,
    status TEXT NOT NULL,
    message TEXT,
    executed_at TIMESTAMPTZ DEFAULT NOW()
);

-- [Section 5.1] Cron Wrapper Function
-- Wraps execution in a log block for audit trail.
CREATE OR REPLACE FUNCTION public.run_cron_job(p_job_name TEXT, p_sql TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    BEGIN
        EXECUTE p_sql;
        INSERT INTO public.cron_audit_logs (job_name, status, message) 
        VALUES (p_job_name, 'success', 'Executed successfully');
    EXCEPTION WHEN OTHERS THEN
        INSERT INTO public.cron_audit_logs (job_name, status, message) 
        VALUES (p_job_name, 'error', SQLERRM);
    END;
END;
$$;

-- [Section 5.1] Schedules

-- 1. Keep-Alive (Every Minute)
SELECT cron.schedule(
    'keep_alive',
    '* * * * *',
    $$ SELECT 1 $$
);

-- 2. Orphan Cleanup (Daily 03:00 UTC)
-- Deletes files in 'posts' bucket that are NOT referenced in 'posts' table
-- AND are older than 24 hours (to safely allow upload-in-progress).
SELECT cron.schedule(
    'orphan_cleanup',
    '0 3 * * *',
    $$ SELECT public.run_cron_job(
        'orphan_cleanup', 
        'DELETE FROM storage.objects 
         WHERE bucket_id = ''posts'' 
         AND created_at < NOW() - INTERVAL ''24 hours''
         AND name NOT IN (SELECT storage_path FROM public.posts)'
       ) $$
);

-- 3. Job Retention (Daily 04:00 UTC)
-- Hard delete completed/dead jobs older than 24 hours to keep table light.
SELECT cron.schedule(
    'job_retention',
    '0 4 * * *',
    $$ SELECT public.run_cron_job(
        'job_retention', 
        'DELETE FROM public.generation_jobs 
         WHERE status IN (''completed'', ''dead'', ''failed'') 
         AND created_at < NOW() - INTERVAL ''24 hours'''
       ) $$
);
