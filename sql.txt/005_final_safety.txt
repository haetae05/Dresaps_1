-- [DRESAPS V4.0] Final Safety & Admin Logic (Domain 13)
-- Section 4. Safety & Section 5. Archiving
-- Generated by Antigravity Agent

-- 1. Soft Delete Rule [D-03]
-- Prevents accidental or malicious data loss by intercepting DELETE commands.
-- Instead of deleting, we mark 'deleted_at'.

-- Ensure deleted_at column exists
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;

-- Create Rule: Substitute DELETE with UPDATE
CREATE OR REPLACE RULE protect_posts_delete AS
ON DELETE TO public.posts
DO INSTEAD
UPDATE public.posts
SET deleted_at = NOW()
WHERE id = OLD.id AND deleted_at IS NULL;

-- Note: RLS policies should ideally filter out deleted items for normal views.
-- e.g. CREATE POLICY "Active Posts" ON public.posts FOR SELECT USING (deleted_at IS NULL);
-- We assume the application logic handles filtering or a VIEW is used.


-- 2. Storage for Archiving (WORM) [Section 5.2]
-- Magazine Bucket: Public Read, Service Role Write, NO Mod/Del.
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES
  ('magazine', 'magazine', false, 52428800, ARRAY['application/json', 'image/webp', 'image/jpeg', 'image/png']) -- 50MB
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

-- Policy: Public Read
CREATE POLICY "Public Read Magazine"
ON storage.objects FOR SELECT
USING ( bucket_id = 'magazine' );

-- Policy: Write/Delete
-- We DO NOT create INSERT/UPDATE/DELETE policies for 'authenticated' users.
-- This effectively makes it Read-Only for users.
-- Service Role (System) allows full access by default.


-- 3. Admin Utilities [Section 4]

-- [D-10] Admin Check Function
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.profiles
        WHERE id = auth.uid()
        AND role IN ('admin', 'gm')
    );
END;
$$;

-- [D-04] Safe Report Status Check (Security Definer)
-- Requires a reports table (Creating minimal structure if not exists)
CREATE TABLE IF NOT EXISTS public.reports (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    reporter_id UUID REFERENCES auth.users(id),
    target_id UUID REFERENCES auth.users(id),
    reason TEXT,
    status TEXT DEFAULT 'pending', -- pending, resolved, dismissed
    admin_note TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- Users can only insert (Report someone)
CREATE POLICY "Users can report" 
ON public.reports FOR INSERT 
WITH CHECK (auth.uid() = reporter_id);

-- Users CANNOT select reports table directly (Prevents retaliation info leaks).
-- They must use the Secure Function below.

CREATE OR REPLACE FUNCTION public.get_my_report_status()
RETURNS TABLE (
    report_id UUID,
    status TEXT,
    created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT id, reports.status, reports.created_at
    FROM public.reports
    WHERE reporter_id = auth.uid();
END;
$$;
