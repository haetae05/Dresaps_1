-- [DRESAPS V4.0] Domain 03 & 04: Social Platform
-- Generated by Antigravity Agent
-- Ref: 069_domain_social.sql

-- 1. Profile Stats Enhancement [Requirement 4]
-- Denormalized counters for high performance.

ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS follower_count INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS following_count INT DEFAULT 0;


-- 2. Social Graph (Relationships) [Requirement 1]
-- Handles Follows and Blocks.
-- Status: 'FOLLOW' or 'BLOCK'.

CREATE TABLE IF NOT EXISTS public.relationships (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    follower_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    following_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('FOLLOW', 'BLOCK')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT no_self_follow CHECK (follower_id != following_id),
    CONSTRAINT unique_relationship UNIQUE (follower_id, following_id)
);

-- RLS: Relationships
ALTER TABLE public.relationships ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see relationships involving them
CREATE POLICY "View own relationships"
ON public.relationships FOR SELECT
USING (auth.uid() = follower_id OR auth.uid() = following_id);

-- Policy: Users can manage their own FOLLOW/BLOCK actions (Insert/Update/Delete)
CREATE POLICY "Manage own following"
ON public.relationships FOR ALL
USING (auth.uid() = follower_id)
WITH CHECK (auth.uid() = follower_id);


-- 3. Trigger: Update Social Stats [Requirement 4]
-- Updates profile counts on INSERT/DELETE of 'FOLLOW'.

CREATE OR REPLACE FUNCTION public.update_social_stats()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        IF NEW.status = 'FOLLOW' THEN
            UPDATE public.profiles SET following_count = following_count + 1 WHERE id = NEW.follower_id;
            UPDATE public.profiles SET follower_count = follower_count + 1 WHERE id = NEW.following_id;
        END IF;
    ELSIF (TG_OP = 'DELETE') THEN
        IF OLD.status = 'FOLLOW' THEN
            UPDATE public.profiles SET following_count = following_count - 1 WHERE id = OLD.follower_id;
            UPDATE public.profiles SET follower_count = follower_count - 1 WHERE id = OLD.following_id;
        END IF;
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Handle Status Change (e.g. FOLLOW -> BLOCK)
        IF OLD.status = 'FOLLOW' AND NEW.status = 'BLOCK' THEN
            UPDATE public.profiles SET following_count = following_count - 1 WHERE id = NEW.follower_id;
            UPDATE public.profiles SET follower_count = follower_count - 1 WHERE id = NEW.following_id;
        ELSIF OLD.status = 'BLOCK' AND NEW.status = 'FOLLOW' THEN
            UPDATE public.profiles SET following_count = following_count + 1 WHERE id = NEW.follower_id;
            UPDATE public.profiles SET follower_count = follower_count + 1 WHERE id = NEW.following_id;
        END IF;
    END IF;
    RETURN NULL;
END;
$$;

DROP TRIGGER IF EXISTS trg_update_social_stats ON public.relationships;
CREATE TRIGGER trg_update_social_stats
AFTER INSERT OR UPDATE OR DELETE ON public.relationships
FOR EACH ROW EXECUTE FUNCTION public.update_social_stats();


-- 4. Posts Enhancement & Item Tagging [Requirement 2, 3]

-- 4.1 Posts Schema Update
-- 'posts' table exists from 000_init_schema. We add columns.
ALTER TABLE public.posts
ADD COLUMN IF NOT EXISTS image_urls JSONB DEFAULT '[]'::JSONB,
ADD COLUMN IF NOT EXISTS location_data JSONB DEFAULT NULL,
ADD COLUMN IF NOT EXISTS is_hidden BOOLEAN DEFAULT FALSE; -- Already exists from 064 but safe to re-declare IF NOT EXISTS

-- 4.2 Posts RLS (The Two-Way Block Logic) [Requirement 2]
-- Drop old policy to replace with Block-Aware Policy.

DROP POLICY IF EXISTS "Public view posts" ON public.posts;
DROP POLICY IF EXISTS "Public View Posts" ON public.posts; -- Case sensitivity check

CREATE POLICY "Public view posts block aware"
ON public.posts FOR SELECT
USING (
    (is_hidden = FALSE)
    AND
    (auth.uid() = user_id OR -- Author sees own
     NOT EXISTS (
        SELECT 1 FROM public.relationships r
        WHERE r.status = 'BLOCK'
        AND (
            (r.follower_id = auth.uid() AND r.following_id = posts.user_id) -- I blocked Author
            OR
            (r.follower_id = posts.user_id AND r.following_id = auth.uid()) -- Author blocked Me
        )
     )
    )
);

-- Delete Policy
CREATE POLICY "Authors delete posts"
ON public.posts FOR DELETE USING (auth.uid() = user_id);


-- 5. Post Items (Tagging) [Requirement 3]
-- Bridge table for tagging items in posts.

CREATE TABLE IF NOT EXISTS public.post_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    post_id UUID REFERENCES public.posts(id) ON DELETE CASCADE NOT NULL,
    item_id UUID REFERENCES public.items(id) ON DELETE CASCADE NOT NULL,
    position_data JSONB DEFAULT NULL, -- x, y coords
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT unique_tag UNIQUE (post_id, item_id)
);

-- RLS: Post Items (Visible if Post is visible)
-- Since RLS checks parent, we can just allow public select, or better:
-- Use security barrier view or simple policy.
ALTER TABLE public.post_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "View post tags"
ON public.post_items FOR SELECT USING (true); -- Public can see tags for now.
-- Ideally we valid visiblity via JOIN with posts, but RLS on Bridge tables can be expensive.
-- Assuming "If you can see the post (via Post RLS), you can fetch its tags". 

-- Insert Policy: Author of the POST can insert tags.
-- We need to check if auth.uid() owns the POST.
CREATE POLICY "Authors tag items"
ON public.post_items FOR INSERT
WITH CHECK (
    EXISTS (SELECT 1 FROM public.posts WHERE id = post_id AND user_id = auth.uid())
);


-- 6. Trigger: Check Item Ownership [Requirement 3]
-- "Verify author owns the item in inventory".

CREATE OR REPLACE FUNCTION public.check_item_ownership()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_post_author UUID;
BEGIN
    -- 1. Get Post Author
    SELECT user_id INTO v_post_author FROM public.posts WHERE id = NEW.post_id;
    
    -- 2. Check Inventory
    IF NOT EXISTS (
        SELECT 1 FROM public.inventory 
        WHERE user_id = v_post_author 
        AND item_id = NEW.item_id
    ) THEN
        RAISE EXCEPTION 'Ownership Verification Failed: User does not own this item.';
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_check_tag_ownership ON public.post_items;
CREATE TRIGGER trg_check_tag_ownership
BEFORE INSERT ON public.post_items
FOR EACH ROW EXECUTE FUNCTION public.check_item_ownership();

