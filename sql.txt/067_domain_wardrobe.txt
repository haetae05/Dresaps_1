-- [DRESAPS V4.0] Domain 07: Wardrobe & Item Specs
-- Generated by Antigravity Agent
-- Ref: 067_domain_wardrobe.sql

-- 1. Item Registry (Master Data) [Requirement 1]
-- Immutable definition of items.

CREATE TABLE IF NOT EXISTS public.items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    category TEXT NOT NULL CHECK (category IN ('TOP', 'BOTTOM', 'SHOES', 'ACCESSORY', 'MASK', 'POSE', 'HAIR', 'FACE')),
    brand_name TEXT NOT NULL,
    rarity TEXT NOT NULL DEFAULT 'COMMON' CHECK (rarity IN ('COMMON', 'RARE', 'LEGENDARY', 'EPIC')),
    metadata JSONB NOT NULL DEFAULT '{}'::JSONB, -- Texture, Model URL, Color, etc.
    price_points INT DEFAULT 0 CHECK (price_points >= 0),
    price_credits INT DEFAULT 0 CHECK (price_credits >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS: Items (Public Read Only)
ALTER TABLE public.items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public view items"
ON public.items FOR SELECT USING (true);

-- No INSERT/UPDATE policy for public/authenticated. Admin/Service Role only.


-- 2. User Inventory (Ownership) [Requirement 2]
-- Secure storage for user items.

CREATE TABLE IF NOT EXISTS public.inventory (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    item_id UUID REFERENCES public.items(id) ON DELETE CASCADE NOT NULL,
    is_equipped BOOLEAN DEFAULT FALSE,
    acquired_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT unique_ownership UNIQUE (user_id, item_id) -- One item per user (Non-consumable fashion)
);

-- RLS: Inventory
ALTER TABLE public.inventory ENABLE ROW LEVEL SECURITY;

-- Policy: View Own Inventory
CREATE POLICY "View own inventory"
ON public.inventory FOR SELECT USING (auth.uid() = user_id);

-- Policy: Update Equip Status Only
-- [Requirement 3] User can UPDATE is_equipped.
-- We allow UPDATE generally on the row if owned, but we should ensure they don't change ownership.
-- A trigger can enforce immutability of user_id/item_id if needed, but RLS 'USING' ensures they only touch their own.
CREATE POLICY "Equip own items"
ON public.inventory FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Policy: NO INSERT/DELETE
-- [Requirement 3] "User cannot insert/delete".
-- We simply DO NOT create policies for INSERT/DELETE for the 'authenticated' role.


-- 3. Auto-Unequip Logic (Trigger) [Requirement 4]
-- When equipping an item, unequip others in the same category.

CREATE OR REPLACE FUNCTION public.handle_equip_logic()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_category TEXT;
BEGIN
    -- Only run if setting to TRUE
    IF NEW.is_equipped = TRUE THEN
        -- 1. Get Category of the new item
        SELECT category INTO v_category FROM public.items WHERE id = NEW.item_id;
        
        -- 2. Unequip all OTHER items of this category for this user
        UPDATE public.inventory
        SET is_equipped = FALSE
        WHERE user_id = NEW.user_id
        AND item_id != NEW.item_id
        AND is_equipped = TRUE
        AND item_id IN (
            SELECT id FROM public.items WHERE category = v_category
        );
    END IF;
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_equip_logic ON public.inventory;
CREATE TRIGGER trg_equip_logic
AFTER UPDATE OF is_equipped ON public.inventory
FOR EACH ROW
WHEN (OLD.is_equipped IS DISTINCT FROM NEW.is_equipped AND NEW.is_equipped = TRUE)
EXECUTE FUNCTION public.handle_equip_logic();

-- 4. Indexing for Performance
CREATE INDEX IF NOT EXISTS idx_inventory_user ON public.inventory(user_id);
CREATE INDEX IF NOT EXISTS idx_inventory_item ON public.inventory(item_id);
CREATE INDEX IF NOT EXISTS idx_items_category ON public.items(category);

