-- [DRESAPS V4.0] Domain 05, 09, 12: Activity & Gamification
-- Generated by Antigravity Agent
-- Ref: 070_domain_activity.sql

-- 1. Interaction System (Likes & Comments) [Requirement 1]

-- 1.1 Add Counter Columns to Posts (Performance)
-- likes_count exists in 000, adding comments_count.
ALTER TABLE public.posts 
ADD COLUMN IF NOT EXISTS comments_count INT DEFAULT 0;

-- 1.2 Likes Table (With Anti-Spam Constraint)
CREATE TABLE IF NOT EXISTS public.likes (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    post_id UUID REFERENCES public.posts(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT unique_like UNIQUE (user_id, post_id), -- [Security] Interaction Limits
    PRIMARY KEY (user_id, post_id)
);

-- RLS: Likes
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public view likes" ON public.likes FOR SELECT USING (true);
CREATE POLICY "Users toggle likes" ON public.likes FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 1.3 Comments Table
CREATE TABLE IF NOT EXISTS public.comments (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    post_id UUID REFERENCES public.posts(id) ON DELETE CASCADE NOT NULL,
    content TEXT NOT NULL CHECK (length(content) > 0 AND length(content) <= 1000),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS: Comments
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public view comments" ON public.comments FOR SELECT USING (true);
CREATE POLICY "Users create comments" ON public.comments FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users delete own comments" ON public.comments FOR DELETE USING (auth.uid() = user_id);
-- Update? Use DELETE+INSERT for simplicity or add UPDATE policy if needed. Let's allow UPDATE for now.
CREATE POLICY "Users update own comments" ON public.comments FOR UPDATE USING (auth.uid() = user_id);


-- 1.4 Trigger: Counter Automation [Requirement 1]
-- Updates posts.likes_count/comments_count directly.

CREATE OR REPLACE FUNCTION public.update_post_counters()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF (TG_TABLE_NAME = 'likes') THEN
        IF (TG_OP = 'INSERT') THEN
            UPDATE public.posts SET likes_count = likes_count + 1 WHERE id = NEW.post_id;
        ELSIF (TG_OP = 'DELETE') THEN
            UPDATE public.posts SET likes_count = likes_count - 1 WHERE id = OLD.post_id;
        END IF;
    ELSIF (TG_TABLE_NAME = 'comments') THEN
        IF (TG_OP = 'INSERT') THEN
             UPDATE public.posts SET comments_count = comments_count + 1 WHERE id = NEW.post_id;
        ELSIF (TG_OP = 'DELETE') THEN
             UPDATE public.posts SET comments_count = comments_count - 1 WHERE id = OLD.post_id;
        END IF;
    END IF;
    RETURN NULL;
END;
$$;

DROP TRIGGER IF EXISTS trg_update_likes_count ON public.likes;
CREATE TRIGGER trg_update_likes_count
AFTER INSERT OR DELETE ON public.likes
FOR EACH ROW EXECUTE FUNCTION public.update_post_counters();

DROP TRIGGER IF EXISTS trg_update_comments_count ON public.comments;
CREATE TRIGGER trg_update_comments_count
AFTER INSERT OR DELETE ON public.comments
FOR EACH ROW EXECUTE FUNCTION public.update_post_counters();


-- 2. Quest System (Achievements) [Requirement 2]

CREATE TABLE IF NOT EXISTS public.user_achievements (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    quest_id TEXT NOT NULL, -- e.g., 'FIRST_POST', 'FIRST_LIKE'
    achieved_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::JSONB,
    CONSTRAINT unique_achievement UNIQUE (user_id, quest_id) -- [Security] Prevent Double Reward
);

-- RLS: User Achievements
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users view own achievements" ON public.user_achievements FOR SELECT USING (auth.uid() = user_id);
-- No INSERT/UPDATE for users. System only.


-- 2.1 Trigger: First Post Quest
-- Logic: On Insert Post -> Check Achievement -> Reward -> Log Achievement.

CREATE OR REPLACE FUNCTION public.check_first_post_quest()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_reward_amount BIGINT := 100;
    v_tx_id UUID;
BEGIN
    -- Check if already achieved (Idempotency Step 1)
    IF NOT EXISTS (SELECT 1 FROM public.user_achievements WHERE user_id = NEW.user_id AND quest_id = 'FIRST_POST') THEN
        
        -- A. Grant Reward (Economy)
        -- Call process_transaction from 066
        v_tx_id := public.process_transaction(
            NEW.user_id,
            v_reward_amount,
            'POINT',
            'REWARD',
            'Quest Complete: First Post',
            jsonb_build_object('quest_id', 'FIRST_POST', 'post_id', NEW.id)
        );

        -- B. Record Achievement (Idempotency Step 2)
        INSERT INTO public.user_achievements (user_id, quest_id, metadata)
        VALUES (NEW.user_id, 'FIRST_POST', jsonb_build_object('tx_id', v_tx_id));
        
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_quest_first_post ON public.posts;
CREATE TRIGGER trg_quest_first_post
AFTER INSERT ON public.posts
FOR EACH ROW EXECUTE FUNCTION public.check_first_post_quest();


-- 3. Ranking System [Requirement 3]
-- View: Real-time calculation of top users.
-- Filter: Reputation >= 75 (Hell Gate).

CREATE OR REPLACE VIEW public.ranking_weekly AS
SELECT
    p.id as user_id,
    p.username,
    p.display_name,
    p.avatar_url,
    p.reputation,
    -- Score Calculation
    (
        (COALESCE(post_stats.post_count, 0) * 5) +
        (COALESCE(post_stats.total_likes_received, 0) * 2) +
        (COALESCE(inv_stats.item_count, 0) * 10)
    ) as score,
    dense_rank() OVER (ORDER BY (
        (COALESCE(post_stats.post_count, 0) * 5) +
        (COALESCE(post_stats.total_likes_received, 0) * 2) +
        (COALESCE(inv_stats.item_count, 0) * 10)
    ) DESC) as rank
FROM public.profiles p
-- Aggregations via Subqueries (or Lateral Joins) for cleaner View
LEFT JOIN (
    SELECT user_id, COUNT(*) as post_count, SUM(likes_count) as total_likes_received
    FROM public.posts
    GROUP BY user_id
) post_stats ON p.id = post_stats.user_id
LEFT JOIN (
    SELECT user_id, COUNT(*) as item_count
    FROM public.inventory
    GROUP BY user_id
) inv_stats ON p.id = inv_stats.user_id
WHERE p.reputation >= 75 -- [Security] Hell Gate Filter
ORDER BY score DESC
LIMIT 100;

-- Submit Permissions
GRANT SELECT ON public.ranking_weekly TO authenticated, service_role;
