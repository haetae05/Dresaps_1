-- [DRESAPS V4.0] Domain 01: User Identity (Implementation)
-- Generated by Antigravity Agent
-- Ref: 065_domain_identity.sql

-- 1. Profile Expansion [Requirement 1]
-- Adding new columns to profiles if they don't exist.
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS bio TEXT,
ADD COLUMN IF NOT EXISTS website_url TEXT,
ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE;

-- 2. Secure Body Specs (Privacy Vault) [Requirement 2]
-- Strategy: Separate Table for strict RLS (Private by default).
-- This handles the "body_specs" (JSONB) requirement securely.

CREATE TABLE IF NOT EXISTS public.user_body_specs (
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE PRIMARY KEY,
    specs JSONB DEFAULT '{}'::JSONB, -- Stores height, weight, scan data types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for Body Specs
ALTER TABLE public.user_body_specs ENABLE ROW LEVEL SECURITY;

-- STRICT POLICY: Only the owner can SELECT, INSERT, UPDATE.
-- "Privacy Policy: Body info ... never exposed to others"
DROP POLICY IF EXISTS "Owner manage body specs" ON public.user_body_specs;
CREATE POLICY "Owner manage body specs"
ON public.user_body_specs
FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Deny all others (Implicitly done by enabling RLS and having only one policy)


-- 3. Data Integrity [Requirement 3]
-- Nickname (username) rules: 3~20 chars, alphanumeric only (no special chars).
-- Note: 'username' column exists in profiles from 000_init_schema.

-- Constraint: Length check
ALTER TABLE public.profiles
DROP CONSTRAINT IF EXISTS check_username_length;
ALTER TABLE public.profiles
ADD CONSTRAINT check_username_length CHECK (char_length(username) BETWEEN 3 AND 20);

-- Constraint: Alphanumeric check (Regex)
-- Allows a-z, A-Z, 0-9, and underscores. Adjust regex if strictly no special chars including underscore.
-- Prompt said "No special characters". Usually implies alphanumeric only.
ALTER TABLE public.profiles
DROP CONSTRAINT IF EXISTS check_username_format;
ALTER TABLE public.profiles
ADD CONSTRAINT check_username_format CHECK (username ~* '^[a-zA-Z0-9]+$');


-- 4. Audit Logging Trigger [Requirement 3]
-- Log changes to sensitive fields (bio, website, body_specs via its own table).

CREATE OR REPLACE FUNCTION public.log_identity_changes()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    INSERT INTO public.audit_logs (action, target_id, metadata)
    VALUES (
        'IDENTITY_UPDATE',
        NEW.id, -- or NEW.user_id for specs
        jsonb_build_object(
            'table', TG_TABLE_NAME,
            'column', 'sensitive_update',
            'timestamp', NOW()
        )
    );
    RETURN NEW;
END;
$$;

-- Trigger for Profiles (Bio/Website changes)
DROP TRIGGER IF EXISTS trg_audit_profile_update ON public.profiles;
CREATE TRIGGER trg_audit_profile_update
AFTER UPDATE OF bio, website_url, username ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.log_identity_changes();

-- Trigger for Body Specs (Any change)
DROP TRIGGER IF EXISTS trg_audit_specs_update ON public.user_body_specs;
CREATE TRIGGER trg_audit_specs_update
AFTER UPDATE ON public.user_body_specs
FOR EACH ROW EXECUTE FUNCTION public.log_identity_changes();


-- 5. Automation Trigger (Atomic Onboarding) [Requirement 4]
-- Override handle_new_user from 001_logic_functions.sql

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- 1. Create Profile
    INSERT INTO public.profiles (id, username, display_name, avatar_url, reputation_score, onboarding_completed, bio)
    VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'username', 'user_' || substr(NEW.id::text, 1, 8)), -- Fallback username if missing
        NEW.raw_user_meta_data->>'display_name',
        NEW.raw_user_meta_data->>'avatar_url',
        100, -- Default Reputation
        FALSE, -- Not boarded
        NULL
    )
    ON CONFLICT (id) DO NOTHING; -- Idempotency

    -- 2. Init Body Specs (Empty)
    INSERT INTO public.user_body_specs (user_id, specs)
    VALUES (NEW.id, NULL)
    ON CONFLICT (user_id) DO NOTHING;

    -- 3. Log Creation
    INSERT INTO public.audit_logs (action, target_id, metadata)
    VALUES ('USER_CREATED', NEW.id, '{"source": "auth_trigger"}'::jsonb);

    RETURN NEW;
END;
$$;

-- Ensure trigger is attached (Redundant but safe)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
