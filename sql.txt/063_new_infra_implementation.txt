-- [DRESAPS V4.0] Domain 13 v1.2 New Infrastructure Implementation
-- Section 5.4, 5.5, Domain 07, Domain 11, Domain 12
-- Generated by Antigravity Agent

-- 1. [Domain 07] Dual-Wallet Architecture (Section 5.4)
/*
   [Wallet Separation]
   - Separates 'Free Films' (Non-withdrawable) from 'Revenue Films' (Withdrawable).
   - Enforces non-negative balances.
*/

ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS film_free INT DEFAULT 0 CHECK (film_free >= 0),
ADD COLUMN IF NOT EXISTS film_revenue INT DEFAULT 0 CHECK (film_revenue >= 0),
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'ACTIVE'; -- Needed for [Domain 13] Watchdog

-- Data Migration (Safe Transition)
DO $$
BEGIN
    -- If 'film' column exists (Legacy), migrate to 'film_free'
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'film') THEN
        EXECUTE 'UPDATE public.profiles SET film_free = film_free + film WHERE film > 0';
        -- We do not drop the legacy column to prevent data loss, as requested.
    END IF;

    -- If 'film_balance' column exists (Alternative Legacy), migrate to 'film_free'
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'film_balance') THEN
        EXECUTE 'UPDATE public.profiles SET film_free = film_free + film_balance WHERE film_balance > 0';
    END IF;
END $$;


-- 2. [Domain 11] Growth Tree (Section 5.5)
/*
   [Referral System]
   - Tracks inviter-invitee relationships.
   - Recursive query for tree traversal.
*/

CREATE TABLE IF NOT EXISTS public.referrals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    inviter_id UUID NOT NULL REFERENCES public.profiles(id),
    invitee_id UUID NOT NULL REFERENCES public.profiles(id) UNIQUE, -- One inviter per user
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_referrals_inviter ON public.referrals(inviter_id);

CREATE OR REPLACE FUNCTION public.get_referral_tree(start_user_id UUID, max_depth INT)
RETURNS TABLE (
    user_id UUID,
    inviter_id UUID,
    depth INT,
    path UUID[]
) LANGUAGE sql STABLE AS $$
WITH RECURSIVE referral_tree AS (
    -- Base case: Direct invitees
    SELECT 
        invitee_id AS user_id, 
        inviter_id, 
        1 AS depth, 
        ARRAY[inviter_id, invitee_id] AS path
    FROM public.referrals
    WHERE inviter_id = start_user_id
    
    UNION ALL
    
    -- Recursive step: Invitees of invitees
    SELECT 
        c.invitee_id, 
        c.inviter_id, 
        p.depth + 1, 
        p.path || c.invitee_id
    FROM public.referrals c
    JOIN referral_tree p ON c.inviter_id = p.user_id
    WHERE p.depth < max_depth
)
SELECT * FROM referral_tree;
$$;


-- 3. [Domain 13] Zero-Sum Watchdog (Section 5.4)
/*
   [Integrity Verifier]
   - Compares Profile Balance vs Ledger Sum.
   - Auto-freezes accounts with discrepancies.
*/

CREATE OR REPLACE FUNCTION public.verify_ledger_integrity()
RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_discrepancy RECORD;
BEGIN
    FOR v_discrepancy IN
        WITH profile_balances AS (
            SELECT id, (COALESCE(film_free, 0) + COALESCE(film_revenue, 0)) as current_balance
            FROM public.profiles
        ),
        ledger_balances AS (
            SELECT user_id, SUM(amount) as ledger_total
            FROM public.film_ledger
            GROUP BY user_id
        )
        SELECT 
            p.id, 
            p.current_balance, 
            COALESCE(l.ledger_total, 0) as ledger_total
        FROM profile_balances p
        LEFT JOIN ledger_balances l ON p.id = l.user_id
        WHERE p.current_balance != COALESCE(l.ledger_total, 0)
    LOOP
        -- Freeze functionality
        UPDATE public.profiles SET status = 'FROZEN' WHERE id = v_discrepancy.id;
        
        -- Logging (Ensure audit_logs exists from previous migration)
        INSERT INTO public.audit_logs (action, target_id, metadata)
        VALUES ('INTEGRITY_FREEZE', v_discrepancy.id, jsonb_build_object(
            'reason', 'Ledger Mismatch',
            'profile_balance', v_discrepancy.current_balance,
            'ledger_total', v_discrepancy.ledger_total
        ));
    END LOOP;
END;
$$;

-- Schedule: Daily at 04:00 UTC
-- Safe execution only if pg_cron exists
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
        PERFORM cron.schedule('zero_sum_watchdog', '0 4 * * *', $$SELECT public.verify_ledger_integrity()$$);
    END IF;
EXCEPTION WHEN OTHERS THEN
    NULL; -- Ignore if cron schema is not accessible or permission denied
END $$;


-- 4. [Extensions] Performance & Security
/*
   [Advanced Features]
   - Vector for AI Search.
   - PGCrypto for Signatures.
*/

CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DO $$ 
BEGIN
    -- AI Commerce Support
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'shop_items') THEN
        ALTER TABLE public.shop_items ADD COLUMN IF NOT EXISTS embedding vector(512);
        
        -- HNSW Index for High-Speed Similarity Search
        CREATE INDEX IF NOT EXISTS idx_shop_items_embedding 
        ON public.shop_items USING hnsw (embedding vector_cosine_ops);
    END IF;
END $$;


-- Section 5: Domain 12 Operations & Security

-- 5-1. [Domain 12] Hell Gate Migration (Threshold Shift to 75)
/*
   [Threshold Adjustment]
   - Old Critical: < 50
   - New Critical: < 75 (Stricter Policy)
   - Action: Retroactive Status Update for users in the gap (50-74).
*/
UPDATE public.profiles
SET status = 'CRITICAL'
WHERE reputation_score >= 50 AND reputation_score < 75 AND status != 'FROZEN';

CREATE OR REPLACE FUNCTION public.handle_reputation_change()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    IF NEW.reputation_score < 75 THEN
        NEW.status := 'CRITICAL';
    ELSIF NEW.reputation_score < 90 THEN
        NEW.status := 'WARNING';
    ELSE
        NEW.status := 'NORMAL'; -- or whatever default status is
    END IF;
    RETURN NEW;
END;
$$;
-- Note: Trigger attachment is assumed to be handled in previous migrations or manually if needed.
-- But for completeness if not exists:
DROP TRIGGER IF EXISTS trg_reputation_change ON public.profiles;
CREATE TRIGGER trg_reputation_change
BEFORE INSERT OR UPDATE OF reputation_score ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.handle_reputation_change();


-- 5-2. [Domain 12] Ghost Protocol (Shadow Ban)
/*
   [Shadow Ban Logic]
   - Reputation < 75 Users are "Ghosts".
   - Their posts are hidden by default (is_hidden = TRUE).
*/

-- Schema Update
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS is_hidden BOOLEAN DEFAULT FALSE;
ALTER TABLE public.comments ADD COLUMN IF NOT EXISTS is_hidden BOOLEAN DEFAULT FALSE;

-- Trigger Function
CREATE OR REPLACE FUNCTION public.enforce_ghost_protocol()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
    user_score INT;
BEGIN
    SELECT reputation_score INTO user_score FROM public.profiles WHERE id = NEW.user_id;
    
    -- If score < 75, force hide content
    IF user_score < 75 THEN
        NEW.is_hidden := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Trigger Attachment
DROP TRIGGER IF EXISTS trg_ghost_posts ON public.posts;
CREATE TRIGGER trg_ghost_posts
BEFORE INSERT ON public.posts
FOR EACH ROW EXECUTE FUNCTION public.enforce_ghost_protocol();

DROP TRIGGER IF EXISTS trg_ghost_comments ON public.comments;
CREATE TRIGGER trg_ghost_comments
BEFORE INSERT ON public.comments
FOR EACH ROW EXECUTE FUNCTION public.enforce_ghost_protocol();

-- RLS Update (Visibility Logic)
-- Note: Policies must be dropped first to avoid errors if they act differently
DROP POLICY IF EXISTS "Public View Posts" ON public.posts;
CREATE POLICY "Public View Posts" ON public.posts
FOR SELECT USING (
    (is_hidden = FALSE) OR (auth.uid() = user_id)
);

DROP POLICY IF EXISTS "Public View Comments" ON public.comments;
CREATE POLICY "Public View Comments" ON public.comments
FOR SELECT USING (
    (is_hidden = FALSE) OR (auth.uid() = user_id)
);


-- 5-3. [Domain 12] Evidence Freezing (Secure Storage)
/*
   [Evidence Bucket]
   - Strictly isolated bucket for reported content snapshots.
   - Public Access: FALSE (System only).
*/
INSERT INTO storage.buckets (id, name, public)
VALUES ('evidence_archive', 'evidence_archive', FALSE)
ON CONFLICT (id) DO NOTHING;
-- Policy: Deny all public access (Implicit default, but explicit denial is safer if needed)
-- Since public is FALSE, RLS is active. We need to ensure no public policy exists.
-- (No specific policy needed if we rely on service role for writing/reading evidence).


-- 5-4. [Domain 13] Latency Penalty Helper
/*
   [Computed Status]
   - DB-level calculation for Middleware efficiency.
   - Middleware checks 'is_hell_gate_target' boolean instead of parsing score.
*/
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS is_hell_gate_target BOOLEAN 
GENERATED ALWAYS AS (reputation_score < 75) STORED;
