-- [DRESAPS V4.0] Domain 06: Economy (FinTech Level)
-- Generated by Antigravity Agent
-- Ref: 066_domain_economy.sql

-- 1. Wallets Table [Requirement 1]
-- Secure container for User Assets (Points, Credits).
-- Constraint: No negative balance allowed at DB level.

CREATE TABLE IF NOT EXISTS public.wallets (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    points BIGINT DEFAULT 0 CHECK (points >= 0),
    credits BIGINT DEFAULT 0 CHECK (credits >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    version INT DEFAULT 1 -- Optimistic Locking support (optional, but good for FinTech)
);

-- RLS: Wallets
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

-- Policy: Users can VIEW their own wallet.
-- STRICTLY NO UPDATE/INSERT policy for users. Only System (Service Role/Functions) can modify.
CREATE POLICY "Users view own wallet"
ON public.wallets FOR SELECT USING (auth.uid() = user_id);


-- 2. Transactions Table (Ledger) [Requirement 1]
-- Immutable record of all financial movements.
-- Type: DEPOSIT (+), WITHDRAWAL (-)

CREATE TABLE IF NOT EXISTS public.transactions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.wallets(user_id) ON DELETE CASCADE NOT NULL,
    amount BIGINT NOT NULL CHECK (amount != 0), -- Positive only? Or signed? Let's use signed for absolute clarity in ledger sum.
    currency_type TEXT NOT NULL CHECK (currency_type IN ('POINT', 'CREDIT')),
    transaction_type TEXT NOT NULL CHECK (transaction_type IN ('DEPOSIT', 'WITHDRAWAL', 'REFUND', 'PURCHASE', 'REWARD')),
    description TEXT,
    status TEXT DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'SUCCESS', 'FAILED')),
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS: Transactions
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- Policy: Users view own transactions
CREATE POLICY "Users view own transactions"
ON public.transactions FOR SELECT USING (auth.uid() = user_id);

-- Immutable Ledger: No UPDATE/DELETE allowed for anyone.
-- INSERT only via System Functions.


-- 3. Concurrency Control Transaction Function [Requirement 2]
-- The Heart of the System.
-- Uses `SELECT ... FOR UPDATE` to lock the wallet row.

CREATE OR REPLACE FUNCTION public.process_transaction(
    p_user_id UUID,
    p_amount BIGINT, -- Positive for Deposit, Negative for Withdrawal
    p_currency_type TEXT, -- 'POINT' or 'CREDIT'
    p_transaction_type TEXT, -- 'DEPOSIT', 'WITHDRAWAL', etc.
    p_description TEXT,
    p_metadata JSONB DEFAULT '{}'::JSONB
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER -- Bypass RLS
AS $$
DECLARE
    v_tx_id UUID;
    v_current_balance BIGINT;
    v_new_balance BIGINT;
BEGIN
    -- A. Input Validation
    IF p_amount = 0 THEN
        RAISE EXCEPTION 'Transaction amount cannot be zero';
    END IF;

    -- B. Start Transaction Recording (Pending)
    INSERT INTO public.transactions (user_id, amount, currency_type, transaction_type, description, status, metadata)
    VALUES (p_user_id, p_amount, p_currency_type, p_transaction_type, p_description, 'PENDING', p_metadata)
    RETURNING id INTO v_tx_id;

    -- C. Lock & Update Wallet (Critical Section)
    -- [CRITICAL] FOR UPDATE locks this row. Concurrent txs wait here.
    
    IF p_currency_type = 'POINT' THEN
        SELECT points INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
        
        IF NOT FOUND THEN
             -- Auto-create wallet if missing (Safety net)
            INSERT INTO public.wallets (user_id) VALUES (p_user_id) RETURNING points INTO v_current_balance;
             -- Re-lock just in case (though insert locks it)
             SELECT points INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
        END IF;

        v_new_balance := v_current_balance + p_amount;

        -- Check Sufficiency (For withdrawal)
        IF v_new_balance < 0 THEN
            UPDATE public.transactions SET status = 'FAILED', metadata = jsonb_set(metadata, '{failure_reason}', '"Insufficient Funds"') WHERE id = v_tx_id;
            RAISE EXCEPTION 'Insufficient Funds: Current %, Attempted %', v_current_balance, p_amount;
        END IF;

        -- Update
        UPDATE public.wallets SET points = v_new_balance, updated_at = NOW() WHERE user_id = p_user_id;

    ELSIF p_currency_type = 'CREDIT' THEN
        SELECT credits INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;

        IF NOT FOUND THEN
             INSERT INTO public.wallets (user_id) VALUES (p_user_id) RETURNING credits INTO v_current_balance;
             SELECT credits INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
        END IF;

        v_new_balance := v_current_balance + p_amount;

        IF v_new_balance < 0 THEN
             UPDATE public.transactions SET status = 'FAILED', metadata = jsonb_set(metadata, '{failure_reason}', '"Insufficient Funds"') WHERE id = v_tx_id;
             RAISE EXCEPTION 'Insufficient Funds: Current %, Attempted %', v_current_balance, p_amount;
        END IF;

        UPDATE public.wallets SET credits = v_new_balance, updated_at = NOW() WHERE user_id = p_user_id;

    ELSE
        RAISE EXCEPTION 'Invalid Currency Type: %', p_currency_type;
    END IF;

    -- D. Finalize Transaction
    UPDATE public.transactions SET status = 'SUCCESS' WHERE id = v_tx_id;

    RETURN v_tx_id;

EXCEPTION WHEN OTHERS THEN
    -- Capture generic errors into Failed status if possible, but simpler to just Rollback for atomicity in critical systems.
    -- However, we want to update the Tx status to FAILED if it was created.
    -- In Postgres function, if we raise exception, the whole tx rolls back including the INSERT into transactions.
    -- To keep the "FAILED" record, we would need a separate commit or block.
    -- Standard practice: Rollback everything ensures no partial state. The client receives error.
    RAISE; 
END;
$$;


-- 4. Automation & Migration [Requirement 3]
-- Trigger to create wallet when User Created.

CREATE OR REPLACE FUNCTION public.handle_new_wallet()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.wallets (user_id)
    VALUES (NEW.id)
    ON CONFLICT (user_id) DO NOTHING;
    RETURN NEW;
END;
$$;

-- Bind to Auth Users (Reuse handle_new_user logic or separate?)
-- Separate trigger is cleaner for modularity.
DROP TRIGGER IF EXISTS on_auth_user_created_wallet ON auth.users;
CREATE TRIGGER on_auth_user_created_wallet
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_wallet();

-- Migration: Backfill for existing users
-- If users exist in auth.users but not in wallets, create them.
INSERT INTO public.wallets (user_id)
SELECT id FROM auth.users
WHERE id NOT IN (SELECT user_id FROM public.wallets)
ON CONFLICT DO NOTHING;

