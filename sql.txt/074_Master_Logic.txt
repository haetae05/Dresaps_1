-- [DRESAPS V4.0] 02_Master_Logic.sql
-- Master Business Logic (Functions & Triggers)
-- Generated by Antigravity Agent
-- Strict adherence to provided logic definition.
-- Security Mandate: SECURITY DEFINER + SET search_path = public

-- 0. Missing Table Setup (Storage Queue)
-- Required for logic, was missing in 01 DDL.
CREATE TABLE IF NOT EXISTS public.storage_delete_queue (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    bucket_id TEXT NOT NULL,
    storage_path TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.storage_delete_queue ENABLE ROW LEVEL SECURITY;


-- 1. User Onboarding (Handle New User) [Reg 1]
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- 1. Create Profile
    INSERT INTO public.profiles (id, username, display_name, role, reputation_score)
    VALUES (
        NEW.id,
        'user_' || substr(md5(random()::text), 1, 8), -- Temp username
        'New User',
        'user',
        100
    )
    ON CONFLICT (id) DO NOTHING;

    -- 2. Create Wallet
    INSERT INTO public.wallets (user_id, film_free, film_revenue, points)
    VALUES (NEW.id, 0, 0, 0)
    ON CONFLICT (user_id) DO NOTHING;

    -- 3. Create Body Specs (Privacy Vault)
    INSERT INTO public.user_body_specs (user_id, height_encrypted, weight_encrypted, scan_data_path)
    VALUES (NEW.id, NULL, NULL, NULL)
    ON CONFLICT (user_id) DO NOTHING;

    -- 4. Audit Log
    INSERT INTO public.admin_audit_logs (action_type, target_id, metadata)
    VALUES ('USER_CREATED', NEW.id, jsonb_build_object('email', NEW.email));

    RETURN NEW;
END;
$$;

-- Trigger Attachment
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- 2. Economy System (Process Transaction) [Reg 2]
-- Core financial logic. Single Source of Truth.
CREATE OR REPLACE FUNCTION public.process_transaction(
    p_user_id UUID,
    p_amount BIGINT,
    p_currency TEXT, -- 'FILM_FREE', 'FILM_REV', 'POINT'
    p_type TEXT,     -- 'DEPOSIT', 'WITHDRAWAL', 'REFUND'
    p_description TEXT
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tx_id UUID;
    v_current_balance BIGINT;
    v_new_balance BIGINT;
BEGIN
    -- Validate Currency
    IF p_currency NOT IN ('FILM_FREE', 'FILM_REV', 'POINT') THEN
        RAISE EXCEPTION 'Invalid currency: %', p_currency;
    END IF;

    -- Lock Wallet Row for Update
    IF p_currency = 'FILM_FREE' THEN
        SELECT film_free INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
    ELSIF p_currency = 'FILM_REV' THEN
        SELECT film_revenue INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
    ELSIF p_currency = 'POINT' THEN
        SELECT points INTO v_current_balance FROM public.wallets WHERE user_id = p_user_id FOR UPDATE;
    END IF;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Wallet not found for user %', p_user_id;
    END IF;

    -- Calculate New Balance (Logic depends on Type)
    IF p_type = 'DEPOSIT' OR p_type = 'REFUND' THEN
        v_new_balance := v_current_balance + p_amount;
    ELSIF p_type = 'WITHDRAWAL' THEN
        v_new_balance := v_current_balance - p_amount;
    ELSE
        RAISE EXCEPTION 'Invalid transaction type: %', p_type;
    END IF;

    -- Check Negative Balance
    IF v_new_balance < 0 THEN
        RAISE EXCEPTION 'Insufficient funds. Current: %, Required: %', v_current_balance, p_amount;
    END IF;

    -- Update Wallet
    IF p_currency = 'FILM_FREE' THEN
        UPDATE public.wallets SET film_free = v_new_balance, updated_at = NOW() WHERE user_id = p_user_id;
    ELSIF p_currency = 'FILM_REV' THEN
        UPDATE public.wallets SET film_revenue = v_new_balance, updated_at = NOW() WHERE user_id = p_user_id;
    ELSIF p_currency = 'POINT' THEN
        UPDATE public.wallets SET points = v_new_balance, updated_at = NOW() WHERE user_id = p_user_id;
    END IF;

    -- Immutable Ledger Record
    INSERT INTO public.transactions (user_id, amount, currency_type, type, description)
    VALUES (p_user_id, p_amount, p_currency, p_type, p_description)
    RETURNING id INTO v_tx_id;

    RETURN v_tx_id;
END;
$$;


-- 3. Shop & Inventory (Purchase Item) [Reg 3]
CREATE OR REPLACE FUNCTION public.purchase_item(
    p_item_id UUID,
    p_currency TEXT
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_item RECORD;
    v_tx_id UUID;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN RAISE EXCEPTION 'Not authenticated'; END IF;

    -- 1. Fetch Item & Validate Status
    SELECT * INTO v_item FROM public.items WHERE id = p_item_id;
    IF NOT FOUND THEN RAISE EXCEPTION 'Item not found'; END IF;
    
    IF v_item.is_active = FALSE THEN
        RAISE EXCEPTION 'Item is not active';
    END IF;

    -- Check Qty Limit
    IF v_item.qty_limit IS NOT NULL AND v_item.qty_sold >= v_item.qty_limit THEN
        RAISE EXCEPTION 'Item sold out';
    END IF;

    -- 2. Check Ownership (Duplicate Prevention)
    IF EXISTS (SELECT 1 FROM public.inventory WHERE user_id = v_user_id AND item_id = p_item_id) THEN
        RAISE EXCEPTION 'Item already owned';
    END IF;

    -- 3. Process Transaction (Deduct Funds)
    -- This handles balance check. Raises exception on failure -> Rollback.
    -- (Assuming price is in Points or Films based on param logic. Assuming simple mapped price for now)
    -- Implementation Detail: Schema has price_film (INT). If paying with POINTS, need conversion or error?
    -- Prompt implies 'p_currency'. Let's assume price_film is the cost.
    -- If p_currency is POINT, maybe 1:1? Or Block? User asked for Logic based on strict reqs.
    -- "Logic 3: Call process_transaction to deduct funds."
    -- Let's use `v_item.price_film` amount.
    
    v_tx_id := public.process_transaction(
        v_user_id,
        v_item.price_film::BIGINT,
        p_currency,
        'WITHDRAWAL',
        'Purchase: ' || v_item.brand_name
    );

    -- 4. Insert Inventory
    INSERT INTO public.inventory (user_id, item_id, is_equipped)
    VALUES (v_user_id, p_item_id, FALSE);

    -- 5. Update Sold Count
    UPDATE public.items 
    SET qty_sold = qty_sold + 1, updated_at = NOW() 
    WHERE id = p_item_id;

    RETURN v_tx_id;
END;
$$;


-- 4. Job Queue Worker (Fetch Next Job) [Reg 4]
CREATE OR REPLACE FUNCTION public.fetch_next_job(
    p_worker_id UUID,
    p_job_types public.job_type[] -- Array of types
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_job_record RECORD;
BEGIN
    -- Select Oldest Pending & Lock
    -- SKIP LOCKED prevents contention
    SELECT * INTO v_job_record
    FROM public.generation_jobs
    WHERE status = 'pending'
      AND job_type = ANY(p_job_types)
    ORDER BY priority DESC, created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED;

    IF v_job_record IS NULL THEN
        RETURN NULL;
    END IF;

    -- Assign Worker & Update Status
    UPDATE public.generation_jobs
    SET status = 'processing',
        worker_id = p_worker_id,
        updated_at = NOW()
    WHERE id = v_job_record.id;

    RETURN to_jsonb(v_job_record);
END;
$$;


-- 5. Safety & Hell Gate (On Reputation Change) [Reg 5]
CREATE OR REPLACE FUNCTION public.on_reputation_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- Check Threshold (75)
    IF NEW.reputation_score < 75 THEN
        -- Entering Hell Gate
        -- 1. Soft Ban User (Flag)
        -- Note: is_hell_gate_target is generated column (in 01), so we can't update it directly?
        -- Wait, 01 Master Structure defined it as GENERATED ALWAYS AS (...) STORED.
        -- So we CANNOT update it manually. The DB handles it.
        -- Prompt Requirement: "Update profiles.is_hell_gate_target = true".
        -- CONFLICT: If it's generated, we can't update.
        -- RESOLUTION: If it's generated, we skip updating it (it updates automatically). 
        -- We proceed to hiding posts.
        
        -- 2. Hide Content (Soft Ban)
        UPDATE public.posts 
        SET is_hidden = TRUE 
        WHERE user_id = NEW.id AND is_hidden = FALSE;

    ELSIF NEW.reputation_score >= 75 AND OLD.reputation_score < 75 THEN
        -- Exiting Hell Gate (Restoration)
        -- Restore Content?
        -- Logic says "Restore visibility".
        UPDATE public.posts 
        SET is_hidden = FALSE 
        WHERE user_id = NEW.id;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_reputation_gate ON public.profiles;
CREATE TRIGGER trg_reputation_gate
BEFORE UPDATE OF reputation_score ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.on_reputation_change();


-- 6. Gamification (Cast Vote) [Reg 6]
CREATE OR REPLACE FUNCTION public.cast_vote(
    p_match_id UUID,
    p_voted_user_id UUID
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_match_status TEXT;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN RAISE EXCEPTION 'Not authenticated'; END IF;

    -- 1. Check Match Status
    SELECT status INTO v_match_status FROM public.style_cup_matches WHERE id = p_match_id;
    IF v_match_status IS NULL OR v_match_status != 'ACTIVE' THEN
        RAISE EXCEPTION 'Match is not active';
    END IF;

    -- 2. Insert Vote
    -- Unique constraint (match_id, voter_id) handles double voting (raises constraint violation)
    INSERT INTO public.style_cup_votes (match_id, voter_id, voted_user_id)
    VALUES (p_match_id, v_user_id, p_voted_user_id);

    -- 3. Optional Reward (First vote of day logic skipped to keep it simple unless specified)
    -- Per prompt: "(Optional) Reward voter with 1 point if it's their first vote of the day."
    -- Implementation: Check if any other vote exists today
    IF NOT EXISTS (
        SELECT 1 FROM public.style_cup_votes 
        WHERE voter_id = v_user_id 
        AND created_at > CURRENT_DATE 
        AND match_id != p_match_id -- Don't count current one
    ) THEN
        PERFORM public.process_transaction(
            v_user_id,
            1,
            'POINT',
            'DEPOSIT',
            'Daily Vote Reward'
        );
    END IF;
END;
$$;


-- 7. Soft Delete & Cleanup (Soft Delete Post) [Reg 7]
CREATE OR REPLACE FUNCTION public.soft_delete_post()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- 1. Cancel Deletion & Soft Delete
    UPDATE public.posts
    SET deleted_at = NOW(),
        is_hidden = TRUE
    WHERE id = OLD.id;

    -- 2. Insert into Queue (For async cleanup)
    -- Assumes 'posts.storage_path' is the column
    INSERT INTO public.storage_delete_queue (bucket_id, storage_path)
    VALUES ('posts', OLD.storage_path); -- Bucket name assumption 'posts' or from config

    -- 3. Return NULL to prevent actual DELETE
    RETURN NULL;
END;
$$;

DROP TRIGGER IF EXISTS trg_soft_delete_post ON public.posts;
CREATE TRIGGER trg_soft_delete_post
BEFORE DELETE ON public.posts
FOR EACH ROW EXECUTE FUNCTION public.soft_delete_post();
